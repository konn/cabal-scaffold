{-# START_FILE .gitignore #-}
### https://raw.github.com/github/gitignore/14f8a8b4c51ecc00b18905a95c117954e6c77b9d/Haskell.gitignore

dist
dist-*
cabal-dev
*.o
*.hi
*.hie
*.chi
*.chs.h
*.dyn_o
*.dyn_hi
.hpc
.hsenv
.cabal-sandbox/
cabal.sandbox.config
*.prof
*.aux
*.hp
*.eventlog
.stack-work/
cabal.project.local
cabal.project.local~
.HTF/
.ghc.environment.*
workspace

### https://raw.github.com/github/gitignore/14f8a8b4c51ecc00b18905a95c117954e6c77b9d/Global/VisualStudioCode.gitignore

.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/


### https://raw.github.com/github/gitignore/14f8a8b4c51ecc00b18905a95c117954e6c77b9d/Global/macOS.gitignore

# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk


### https://raw.github.com/github/gitignore/14f8a8b4c51ecc00b18905a95c117954e6c77b9d/Global/Linux.gitignore

*~

# temporary files which can be created if a process still has a handle open of a deleted file
.fuse_hidden*

# KDE directory preferences
.directory

# Linux trash folder which might appear on any partition or disk
.Trash-*

# .nfs files are created when an open file is removed but is still being accessed
.nfs*


### Generated by gibo (https://github.com/simonwhitaker/gibo)
### https://raw.github.com/github/gitignore/e5323759e387ba347a9d50f8b0ddd16502eb71d4/Haskell.gitignore

dist
dist-*
cabal-dev
*.o
*.hi
*.hie
*.chi
*.chs.h
*.dyn_o
*.dyn_hi
.hpc
.hsenv
.cabal-sandbox/
cabal.sandbox.config
*.prof
*.aux
*.hp
*.eventlog
.stack-work/
cabal.project.local
cabal.project.local~
.HTF/
.ghc.environment.*


### https://raw.github.com/github/gitignore/e5323759e387ba347a9d50f8b0ddd16502eb71d4/Global/VisualStudioCode.gitignore

.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
!.vscode/*.code-snippets

# Local History for Visual Studio Code
.history/

# Built Visual Studio Code Extensions
*.vsix


### https://raw.github.com/github/gitignore/e5323759e387ba347a9d50f8b0ddd16502eb71d4/Global/macOS.gitignore

# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk


### https://raw.github.com/github/gitignore/e5323759e387ba347a9d50f8b0ddd16502eb71d4/Global/Linux.gitignore

*~

# temporary files which can be created if a process still has a handle open of a deleted file
.fuse_hidden*

# KDE directory preferences
.directory

# Linux trash folder which might appear on any partition or disk
.Trash-*

# .nfs files are created when an open file is removed but is still being accessed
.nfs*

workspace

{-# START_FILE .pre-commit-config.yaml #-}
default_install_hook_types:
- pre-commit
- post-checkout
- pre-push
repos:
- repo: local
  hooks:
  - id: pre-commit-run-cabal-gild
    name: Formats .cabal files with cabal-gild
    always_run: true
    verbose: true
    stages: [commit]
    language: system
    pass_filenames: false
    entry: bash -c "find . -not -path '**/dist-newstyle/**' -and \\( -name '*.cabal' -or -name 'cabal*.project*' \\) -exec cabal-gild --io {} \\;"

{-# START_FILE README.md #-}
# {{name}}

## Copyright

(c) {{author-name}} {{year}}- present

{-# START_FILE cabal-scaffold.yaml #-}
templateDirs: []
hpack: true

defaults:
  template: monorepo-single
  snapshot: lts
  project-file: false

params:
  monorepo: {{name}}
  author-name: {{author-name}}
  author-email: {{author-email}}
  github-username: {{github-username}}

{-# START_FILE cabal.project #-}
packages: */*.cabal
tests: True
benchmarks: True

{-# START_FILE fourmolu.yaml #-}
indentation: 2
comma-style: leading
record-brace-space: true
indent-wheres: true
diff-friendly-import-export: false
respectful: false
haddock-style: multi-line
newlines-between-decls: 1

{-# START_FILE hie.yaml #-}
cradle:
  cabal:

{-# START_FILE .github/workflows/haskell.yml #-}
{{=<% %>=}}
name: Build and Test
on: 
  push: {branches: ["main"]}
  pull_request:

jobs:

  build:
    name: Build (${{matrix.plan.name}})
    continue-on-error: true
    strategy:
      matrix:
        plan: 
        - path: "cabal.project.freeze"
          name: "ghc-<%ghc%>"
          ghc: "<%ghc%>"
          is_head: false
      fail-fast: false
    env:
      cabal-version: 3.10.2.0
      cabal: "cabal --project-file=${{matrix.plan.path}}"
      ghc: ${{matrix.plan.ghc}}
      project-file: ${{matrix.plan.path}}
      plan: ${{matrix.plan.name}}
      artifact-name: "artifact-${{matrix.plan.name}}"
    runs-on: ubuntu-latest
    outputs:
      benchmarks: ${{steps.list-bins.outputs.benchs}}
      tests: ${{steps.list-bins.outputs.tests}}
      artifact: "artifact-${{matrix.plan.name}}"
    steps:
    - uses: actions/checkout@v3
      with:
        ref: ${{github.event.pull_request.head.sha || github.sha}}
    - name: Calculate hash keys
      uses: actions/github-script@v6
      id: cache-keys
      with:
        script: |
          const script = require('./ci/scripts/calc-cache-keys.js')
          await script({ os: "ubuntu", plan: ${{toJSON(env.plan)}}, path: ${{toJSON(env.project-file)}}, core, glob })

    - name: Setup Haskell
      uses: haskell-actions/setup@v2
      with:
        enable-stack: false
        cabal-version: ${{env.cabal-version}}
        ghc-version: ${{env.ghc}}
    - name: Restore ~/.cabal/store
      uses: actions/cache/restore@v3
      with:
        path: ~/.cabal/store
        key: ${{steps.cache-keys.outputs.store}}
        restore-keys: ${{steps.cache-keys.outputs.store-restore}}
    - name: Restore dist-newstyle
      uses: actions/cache/restore@v3
      with:
        path: dist-newstyle
        key: ${{steps.cache-keys.outputs.dist}}
        restore-keys: ${{steps.cache-keys.outputs.dist-restore}}
    - name: cabal configure
      run: |
        ${{env.cabal}} v2-configure --enable-tests --enable-benchmarks --enable-optimisation=2
        ${{env.cabal}} update
    - name: Build Dependencies
      run: | 
        ${{env.cabal}} build --only-dependencies all
    - name: Save ~/.cabal/store Cache
      uses: actions/cache/save@v3
      with:
        path: ~/.cabal/store
        key: ${{steps.cache-keys.outputs.store}}
    - name: Build All
      run: | 
        ${{env.cabal}} build all
    - name: Save dist-newstyle Cache
      uses: actions/cache/save@v3
      with:
        path: dist-newstyle
        key: ${{steps.cache-keys.outputs.dist}}

    - name: Collect binaries
      continue-on-error: true
      run: bash ./ci/scripts/collect-bins.sh "${{env.artifact-name}}"
    - name: Upload Aritracts
      uses: actions/upload-artifact@v3
      with:
        path: ${{env.artifact-name}}.tar.zst
        name: ${{env.artifact-name}}
        retention-days: 1
    - name: List Binaries
      id: list-bins
      shell: bash
      run: |
        echo "benchs=$(jq -cMnR '[inputs]' <"${{env.artifact-name}}"/benchs.list)" >>"${GITHUB_OUTPUT}"
        echo "tests=$(jq -cMnR '[inputs]' <"${{env.artifact-name}}"/tests.list)" >>"${GITHUB_OUTPUT}"

  test:
    name: Test (${{matrix.plan.name}})
    needs: [build]
    continue-on-error: ${{matrix.plan.is_head}}
    strategy:
      matrix:
        ## TODO: When OSS is ready, use the following line
        # plan: ${{fromJSON(needs.ci-enumerate.outputs.plan)}}

        ## TODO: When OSS is ready, delete the following:
          plan: 
            - path: "cabal.project.freeze"
              name: "ghc-<%ghc%>"
              ghc: "<%ghc%>"
              is_head: false
      fail-fast: false
    env:
      cabal: 3.10.1.0
      ghc: ${{matrix.plan.ghc}}
      project-file: ${{matrix.plan.path}}
      plan: ${{matrix.plan.name}}
      artifact: artifact-${{matrix.plan.name}}
    runs-on: ubuntu-latest
    steps:
      - name: Fail when Corresponding Build didn't succeed
        if: ${{needs.build.result != 'success' }}
        run: echo "BUILD FAILED" >&2; exit 1
      - uses: actions/checkout@v3
        with:
          ref: ${{github.event.pull_request.head.sha || github.sha}}
      - name: Download artifacts
        id: download
        uses: actions/download-artifact@v3
      - name: Decompress
        run: tar xaf ${{env.artifact}}/${{env.artifact}}.tar.zst
      - name: Run Tests
        shell: bash
        run: |
          set -euo pipefail
          TOTAL=0
          SUCCESS=0
          FAIL=0
          while read -r TEST; do
            TOTAL=$((TOTAL + 1))
            echo "--------"
            echo "Running: ${TEST}"
            set +e
            ${{env.artifact}}/tests/"${TEST}"
            RESL=$?
            set -e
            if [ ${RESL} -eq 0 ]; then
              SUCCESS=$((SUCCESS + 1))
              echo "Result: Successed"
            else
              FAIL=$((FAIL + 1))
              echo 'Result: FAILED!'
            fi
          done <${{env.artifact}}/tests.list

          echo ""
          echo "----"

          if [ "${FAIL}" -eq 0 ]; then
            echo "All ${TOTAL} tests passed."
          else
            echo "${FAIL} out of ${TOTAL} tests FAILED"'!'
            exit 1
          fi

  fourmolu:
    name: Fourmolu
    runs-on: ubuntu-latest
    steps:
      # Note that you must checkout your code before running fourmolu/fourmolu-action
      - uses: actions/checkout@v2
      - uses: fourmolu/fourmolu-action@v10
        with:
          pattern: |
            **/*.hs
            !**/Setup.hs
            !**/Setup.lhs
            !dist-newstyle/**
        
  cabal-check:
    name: Cabal Check
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: haskell-actions/setup@v2
      with:
        cabal-version: 3.10.2.0
        ghc-version: 9.4.8
    - run: bash ./ci/scripts/cabal-check-packages.sh
<%={{ }}=%>
{-# START_FILE .vscode/.gitignore #-}
*.local.json
tasks.json
settings.json
launch.json
!extensions.json
!*.shared.json

{-# START_FILE .vscode/extensions.json #-}
{
  // See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.
  // Extension identifier format: ${publisher}.${name}. Example: vscode.csharp

  // List of extensions which should be recommended for users of this workspace.
  "recommendations": [
    "haskell.haskell",
    "emeraldwalk.RunOnSave",
    "Swellaby.workspace-config-plus"
  ],
  // List of extensions recommended by VS Code that should not be recommended for users of this workspace.
  "unwantedRecommendations": []
}

{-# START_FILE .vscode/settings.shared.json #-}
{
  "emeraldwalk.runonsave": {
    "commands": [
      {
        "cmd": "find . -not -path '**/dist-newstyle/**' -and \\( -name '*.cabal' -or -name 'cabal*.project*' \\) -exec cabal-gild --io {} \\;",
        "isAsync": true,
        "match": "(\\.l?hs|cabal.*\\.project.*)$"
      }
    ]
  },
  "files.associations": {
    "cabal*.project*": "cabal"
  },
  "haskell.formattingProvider": "fourmolu"
}

{-# START_FILE .vscode/settings.json #-}
{
  "emeraldwalk.runonsave": {
    "commands": [
      {
        "cmd": "find . -not -path '**/dist-newstyle/**' -and \\( -name '*.cabal' -or -name 'cabal*.project*' \\) -exec cabal-gild --io {} \\;",
        "isAsync": true,
        "match": "(\\.l?hs|cabal.*\\.project.*)$"
      }
    ]
  },
  "files.associations": {
    "cabal*.project*": "cabal"
  },
  "haskell.formattingProvider": "fourmolu"
}
{-# START_FILE ci/scripts/cabal-check-packages.sh #-}
#!/usr/bin/env bash

COUNT=0
FAILS=0
declare GITHUB_STEP_SUMMARY
declare -a invalid=()

set -eux

LOG_FILE=$(readlink -f ./cabal-check-log.log)
touch "${LOG_FILE}"

trap 'rm -f "${LOG_FILE}"' EXIT

while read -r CABAL; do
  echo "Checking ${CABAL}"
  COUNT=$((COUNT + 1))
  pushd "$(dirname "${CABAL}")"
  echo "" >> "${LOG_FILE}"
  PKG=$(basename "${CABAL}")
  PKG="${PKG%.cabal}"
  {
    echo "### ${PKG}"
    echo ""
    echo '```'
  } >> "${LOG_FILE}"

  if ! (cabal check >>"${LOG_FILE}" 2>&1) ; then
    invalid+=("${PKG}")
    FAILS=$((FAILS + 1))
  fi

  {
    echo '```'
    echo ""
  } >> "${LOG_FILE}"
  popd
done < <(find . -name '*.cabal' -not -path './dist-newstyle/**')

if [ "${FAILS}" -gt 0 ]; then
  {
    echo ":no_entry_sign: Cabal check failed for the following packages:"
    echo ""
    for PKG in "${invalid[@]}"; do
      echo "- ${PKG}"
    done

    echo ""
    echo "## Messages"
    echo ""
    cat "${LOG_FILE}"
  } >> "${GITHUB_STEP_SUMMARY}"
  exit 1
else
  { 
    echo ":white_check_mark: All Cabal green!" 
    echo ""

    echo "## Messages"
    echo ""
    cat "${LOG_FILE}"
  } >> "${GITHUB_STEP_SUMMARY}"
fi

{-# START_FILE ci/scripts/calc-cache-keys.js #-}
module.exports = async ({ os, plan, path, core, glob }) => {
  function build_keys(comps) {
    const fallbacks = comps
      .reduce((accum, cur) => [accum[0].concat([cur])].concat(accum), [[]])
      .slice(1, -1)
      .map((e) => e.concat("").join("-"));

    return { key: comps.join("-"), restore: fallbacks.join("\n") };
  }
  const project_hash = await glob.hashFiles("cabal.project", path);
  core.setOutput("project", project_hash);

  const package_hash = await glob.hashFiles("**/*.cabal");
  core.setOutput("package", package_hash);

  const source_hash = await glob.hashFiles(
    "**/*.hs",
    "**/*.lhs",
    "**/*.hsig",
    "**/*.hs-boot",
    "**/*.c",
    "**/*.h",
    "**/*.chs",
    "**/*.hsc"
  );
  core.setOutput("source", source_hash);

  const store_prefix = `store-${os}-${plan}`;
  core.setOutput("store-prefix", store_prefix);
  const store_keys = build_keys([store_prefix, project_hash, package_hash]);
  core.setOutput("store", store_keys.key);
  core.setOutput("store-restore", store_keys.restore);

  const dist_prefix = `dist-${os}-${plan}`;
  core.setOutput("dist-prefix", dist_prefix);
  const dist_key_comps = [dist_prefix, project_hash, package_hash, source_hash];
  const dist_keys = build_keys(dist_key_comps);
  core.setOutput("dist", dist_keys.key);
  core.setOutput("dist-restore", dist_keys.restore);
};

{-# START_FILE ci/scripts/collect-bins.sh #-}
#!/usr/bin/env bash
set -euo pipefail
DEST="$(pwd)/${1}"

echo "[*] Create directory tree"
TESTS="${DEST}"/tests
TESTS_LIST="${DEST}"/tests.list
EXES="${DEST}"/exes
EXES_LIST="${DEST}"/exes.list
BENCHS="${DEST}"/benchs
BENCHS_LIST="${DEST}"/benchs.list
set -x
mkdir -p "${TESTS}"
mkdir -p "${EXES}"
mkdir -p "${BENCHS}"
touch "${TESTS_LIST}"
touch "${EXES_LIST}"
touch "${BENCHS_LIST}"
set +x

echo "[*] Setting-up cabal-plan"
if command -v cabal-plan; then
    echo "cabal-plan found."
    CABAL_PLAN="$(command -v cabal-plan)"
else
    echo "No cabal-plan found."
    set -x
    case "$(uname)" in
        Darwin)
            CABAL_PLAN_URL=https://github.com/konn/cabal-plan/releases/download/v0.7.2.3/cabal-plan-0.7.2.3-macOS-x86_64.xz
        ;;
        *)
            CABAL_PLAN_URL=https://github.com/haskell-hvr/cabal-plan/releases/download/v0.6.2.0/cabal-plan-0.6.2.0-x86_64-linux.xz
        ;;
    esac
    
    wget "${CABAL_PLAN_URL}" -O cabal-plan.xz
    
    xz -d <./cabal-plan.xz >cabal-plan
    chmod +x cabal-plan
    set +x
    CABAL_PLAN="$(pwd)/cabal-plan"
fi

echo "[*] Places artifacts into the correct place"

local_pkgs=()
while read -r TARG; do
    local_pkgs+=("-e" "$(basename "${TARG%*.cabal}")");
done < <(find . -type f -not -path '*/dist-newstyle/*' -name '*.cabal')

${CABAL_PLAN} list-bins | grep "${local_pkgs[@]}" | while read -r TARG; do
    COMPONENT=$(echo "${TARG}" | awk '{ print $1 }')
    BIN=$(echo "${TARG}" | awk '{ print $2 }')
    TYPE=$(echo "${COMPONENT}" | cut -d':' -f2)
    echo "---"
    echo "- Comp: ${COMPONENT}"
    echo "- Path: ${BIN}"
    echo "- Type: ${TYPE}"
    case "${TYPE}" in
        exe)
            COPY_DEST=${EXES}
            LIST=${EXES_LIST}
        ;;
        test)
            COPY_DEST=${TESTS}
            LIST=${TESTS_LIST}
        ;;
        *)
            COPY_DEST=${BENCHS}
            LIST=${BENCHS_LIST}
        ;;
    esac
    if [ -f "${BIN}" ]; then
        echo "Copying to ${COPY_DEST}"
        cp "${BIN}" "${COPY_DEST}/"
        basename "${BIN}" >> "${LIST}"
    else
        echo "Binary not found. Skipped."
    fi
done
echo "[*] Collected. Compressing..."

TARBALL="${DEST}.tar.zst"
tar --use-compress-program="zstdmt -8" -caf "${TARBALL}" "./${1}"
echo "[*] Compressed as: ${TARBALL}"

{-# START_FILE ci/scripts/enumerate-ci.js #-}
module.exports = async ({ github, context, core, glob, io, require }) => {
  const fs = require("fs");
  const globber = await glob.create("ci/configs/*.project");
  const files = await globber.glob();

  function generate_obj(fullpath) {
    const is_head = /-head\.project$/.test(fullpath);
    const path = fullpath.replace(/^.+\//, "ci/configs/");
    const name = fullpath.replaceAll(/.+\/|\.project$/g, "");
    const match = fs
      .readFileSync(fullpath, "utf-8")
      .match(/with-compiler:\s*ghc-([\d\.]+)/);
    const ghc = match[1];

    return { path, name, ghc, is_head };
  }

  const plans = files.map(generate_obj);
  core.info(`plan: ${JSON.stringify(plans)}`);
  core.setOutput("plan", JSON.stringify(plans));
};

{-# START_FILE {{name}}/README.md #-}
# {{name}}

## Copyright

(c) {{author-name}} {{year}}- present

{-# START_FILE {{name}}/{{name}}.cabal #-}
cabal-version: 3.4
name: {{name}}
version: 0.1.0.0
description: Please see the README on GitHub at <https://github.com/{{github-username}}/{{name}}#readme>
homepage: https://github.com/{{github-username}}/{{name}}#readme
bug-reports: https://github.com/{{github-username}}/{{name}}/issues
author: {{author-name}}
maintainer: {{author-email}}
copyright: (c) {{author-name}} {{year}}- present
license: BSD-3-Clause
license-file: LICENSE
build-type: Simple
tested-with:
  ghc ==9.6.6

extra-doc-files:
  CHANGELOG.md
  README.md

source-repository head
  type: git
  location: https://github.com/{{github-username}}/{{name}}
  subdir: {{name}}

common defaults
  other-modules: {{Paths_module}}
  autogen-modules: {{Paths_module}}
  ghc-options:
    -Wall
    -Wcompat
    -Widentities
    -Wincomplete-record-updates
    -Wincomplete-uni-patterns
    -Wmissing-export-lists
    -Wmissing-home-modules
    -Wpartial-fields
    -Wredundant-constraints
    -Wunused-packages

  build-depends: base >=4.7 && <5
  default-language: Haskell2010

library
  import: defaults
  hs-source-dirs: src
  -- cabal-gild: discover src --exclude=src/**/Internal.hs --exclude=src/**/Internal/**/*.hs
  exposed-modules: Lib
  -- cabal-gild: discover src --include=src/**/Internal.hs --include=src/**/Internal/**/*.hs
  other-modules:

executable {{name}}
  import: defaults
  hs-source-dirs: app
  main-is: Main.hs
  -- cabal-gild: discover app --exclude=app/Main.hs
  other-modules:
  ghc-options:
    -threaded
    -rtsopts
    -with-rtsopts=-N

  build-depends: {{name}}

test-suite {{name}}-test
  import: defaults
  type: exitcode-stdio-1.0
  main-is: Test.hs
  hs-source-dirs: test
  -- cabal-gild: discover test --exclude=test/Test.hs
  other-modules:
  ghc-options:
    -threaded
    -O2
    -rtsopts
    -with-rtsopts=-N

  build-depends: {{name}}

{-# START_FILE {{name}}/LICENSE #-}
Copyright {{author-name}} {{year}}- present

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1.  Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

2.  Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

3.  Neither the name of the copyright holder nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

{-# START_FILE {{name}}/Setup.hs #-}
import Distribution.Simple
main = defaultMain

{-# START_FILE {{name}}/CHANGELOG.md #-}
# Changelog for `{{name}}`

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to the
[Haskell Package Versioning Policy](https://pvp.haskell.org/).

## Unreleased

## 0.1.0.0 - YYYY-MM-DD

{-# START_FILE {{name}}/app/Main.hs #-}
module Main (main) where

main :: IO ()
main = pure ()

{-# START_FILE {{name}}/src/Lib.hs #-}
module Lib where

{-# START_FILE {{name}}/test/Test.hs #-}
module Main (main) where

main :: IO ()
main = putStrLn "Test suite not yet implemented"
